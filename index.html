   <!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>BLOCK GAMES</title>

<style>
body {
  margin: 0;
  background: #020824;
  color: white;
  overflow: hidden;
  font-family: sans-serif;
}

header {
  height: 60px;
  line-height: 60px;
  text-align: center;
  font-weight: bold;
  position: relative;
}

#hiscore, #stage, #score, #life {
  position: absolute;
  top: 0;
  font-size: 14px;
}

#hiscore { left: 10px; }
#stage { left: 110px; }
#life { right: 120px; }
#score { right: 10px; }

canvas {
  display: block;
}
</style>
</head>

<body>
<header id="logo">
  BLOCK GAMES
  <span id="hiscore">HI: 0</span>
  <span id="stage">STAGE 1</span>
  <span id="life">❤️❤️❤️❤️❤️</span>
  <span id="score">SCORE: 0</span>
</header>

<canvas id="game"></canvas>

<script>
/* ===== Canvas ===== */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const headerHeight = 60;

function resize() {
  canvas.width = innerWidth;
  canvas.height = innerHeight - headerHeight;
}
resize();
addEventListener("resize", resize);

/* ===== 状態 ===== */
let score = 0;
let hiScore = Number(localStorage.getItem("hiScore")) || 0;
let stage = 1;
let lives = 5;

const scoreEl = document.getElementById("score");
const hiEl = document.getElementById("hiscore");
const stageEl = document.getElementById("stage");
const lifeEl = document.getElementById("life");

function updateUI() {
  scoreEl.textContent = `SCORE: ${score}`;
  hiEl.textContent = `HI: ${hiScore}`;
  stageEl.textContent = `STAGE ${stage}`;
  lifeEl.textContent = "❤️".repeat(lives);
}

/* ===== Audio ===== */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function pop() {
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.frequency.value = 520;
  g.gain.value = 0.05;
  o.connect(g).connect(audioCtx.destination);
  o.start();
  o.stop(audioCtx.currentTime + 0.04);
}

/* ===== Paddle ===== */
const paddle = { w: 100, h: 12, x: 0 };
function resetPaddle() {
  paddle.x = (canvas.width - paddle.w) / 2;
}

/* ===== Balls ===== */
let baseSpeed = 5.5;
let balls = [];

function createBalls() {
  balls = [];
  let count = stage <= 50 ? 1 : stage <= 75 ? 2 : 3;

  for (let i = 0; i < count; i++) {
    balls.push({
      x: canvas.width / 2,
      y: canvas.height / 2,
      r: 6,
      vx: (Math.random() > 0.5 ? 1 : -1) * baseSpeed,
      vy: -baseSpeed
    });
  }
}

/* ===== Speed ===== */
function updateSpeed(ball) {
  let s = baseSpeed + stage * 0.04;
  if (score >= 800) s += 2;
  else if (score >= 500) s += 1.5;
  else if (score >= 300) s += 1;
  else if (score >= 100) s += 0.5;

  ball.vx = Math.sign(ball.vx) * s;
  ball.vy = Math.sign(ball.vy) * s;
}

/* ===== Blocks ===== */
let blocks = [];
const shapes = ["rect", "circle", "heart"];

function createStage() {
  blocks = [];
  const cols = 7;
  const rows = 4 + (stage % 3);
  const bw = canvas.width / cols;
  const shape = shapes[Math.floor(Math.random() * shapes.length)];

  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      if (Math.random() < 0.2) continue;
      blocks.push({
        x: c * bw,
        y: r * 22 + 30,
        w: bw - 4,
        h: 18,
        alive: true,
        shape,
        color: `hsl(${Math.random()*360},80%,60%)`
      });
    }
  }
}

/* ===== Control ===== */
canvas.addEventListener("touchstart", () => audioCtx.resume(), { once:true });
canvas.addEventListener("touchmove", e => {
  paddle.x = e.touches[0].clientX - paddle.w / 2;
  paddle.x = Math.max(0, Math.min(canvas.width - paddle.w, paddle.x));
});

/* ===== Game Loop ===== */
function update() {
  balls.forEach(ball => {
    ball.x += ball.vx;
    ball.y += ball.vy;

    if (ball.x < ball.r || ball.x > canvas.width - ball.r) ball.vx *= -1;
    if (ball.y < ball.r) ball.vy *= -1;

    if (
      ball.y + ball.r > canvas.height - 22 &&
      ball.x > paddle.x &&
      ball.x < paddle.x + paddle.w
    ) {
      ball.vy = -Math.abs(ball.vy);
    }

    blocks.forEach(b => {
      if (!b.alive) return;
      if (
        ball.x > b.x &&
        ball.x < b.x + b.w &&
        ball.y > b.y &&
        ball.y < b.y + b.h
      ) {
        b.alive = false;
        ball.vy *= -1;
        score += 10;
        pop();
        updateSpeed(ball);
        if (score > hiScore) {
          hiScore = score;
          localStorage.setItem("hiScore", hiScore);
        }
      }
    });
  });

  // ボール落下チェック（1個でも落ちたら）
  if (balls.some(b => b.y > canvas.height)) {
    lives--;
    if (lives <= 0) {
      stage = 1;
      score = 0;
      lives = 5;
      baseSpeed = 5.5;
    }
    createStage();
    createBalls();
  }

  if (blocks.every(b => !b.alive)) nextStage();
}

function drawBlock(b) {
  ctx.fillStyle = b.color;
  if (b.shape === "circle") {
    ctx.beginPath();
    ctx.arc(b.x + b.w/2, b.y + b.h/2, b.h/2, 0, Math.PI*2);
    ctx.fill();
  } else if (b.shape === "heart") {
    ctx.beginPath();
    ctx.arc(b.x + b.w*0.3, b.y + b.h/2, b.h/3, 0, Math.PI*2);
    ctx.arc(b.x + b.w*0.7, b.y + b.h/2, b.h/3, 0, Math.PI*2);
    ctx.fill();
  } else {
    ctx.fillRect(b.x, b.y, b.w, b.h);
  }
}

function draw() {
  ctx.clearRect(0,0,canvas.width,canvas.height);

  ctx.fillStyle = "white";
  ctx.fillRect(paddle.x, canvas.height - 22, paddle.w, 12);

  balls.forEach(ball => {
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2);
    ctx.fill();
  });

  blocks.forEach(b => b.alive && drawBlock(b));
}

function nextStage() {
  stage++;
  if (stage > 100) {
    alert("ALL STAGE CLEAR!!");
    stage = 1;
    score = 0;
    lives = 5;
    baseSpeed = 5.5;
  }
  baseSpeed += 0.15;
  createStage();
  createBalls();
}

function loop() {
  update();
  draw();
  updateUI();
  requestAnimationFrame(loop);
}

/* ===== Hidden Search ===== */
let tap = 0;
document.getElementById("logo").onclick = () => {
  tap++;
  setTimeout(()=>tap=0,1500);
  if (tap === 5) location.href = "https://duckduckgo.com";
};

/* ===== Start ===== */
resetPaddle();
createStage();
createBalls();
updateUI();
loop();
</script>
</body>
</html>
